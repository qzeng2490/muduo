diff --git a/CMakeLists.txt b/CMakeLists.txt
index d18840f..8c9f075 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -11,14 +11,15 @@ endif()
 set(CXX_FLAGS
  -g
  # -DVALGRIND
- # -DMUDUO_STD_STRING
- -DCHECK_PTHREAD_RETURN_VALUE
+ # -DCHECK_PTHREAD_RETURN_VALUE
+ -DMUDUO_STD_STRING
  -D_FILE_OFFSET_BITS=64
  -Wall
  -Wextra
- -Werror
+ # -Werror
  -Wconversion
  -Wno-unused-parameter
+ -Wno-sign-conversion
  -Wold-style-cast
  -Woverloaded-virtual
  -Wpointer-arith
@@ -27,16 +28,15 @@ set(CXX_FLAGS
  -march=native
  # -MMD
  # -std=c++0x
- -rdynamic
  )
 if(CMAKE_BUILD_BITS EQUAL 32)
   list(APPEND CXX_FLAGS "-m32")
 endif()
 string(REPLACE ";" " " CMAKE_CXX_FLAGS "${CXX_FLAGS}")
 
-set(CMAKE_CXX_COMPILER "g++")
+set(CMAKE_CXX_COMPILER "clang++")
 set(CMAKE_CXX_FLAGS_DEBUG "-O0")
-set(CMAKE_CXX_FLAGS_RELEASE "-O2 -finline-limit=1000 -DNDEBUG")
+set(CMAKE_CXX_FLAGS_RELEASE "-O2 -DNDEBUG")
 set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
 set(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)


diff --git a/muduo/net/EventLoop.cc b/muduo/net/EventLoop.cc
index 7346838..19fde05 100644
--- a/muduo/net/EventLoop.cc
+++ b/muduo/net/EventLoop.cc
@@ -18,7 +18,8 @@
 #include <boost/bind.hpp>

 #include <signal.h>
-#include <sys/eventfd.h>
+#include <sys/types.h>
+#include <sys/socket.h>

 using namespace muduo;
 using namespace muduo::net;
@@ -29,18 +30,6 @@ __thread EventLoop* t_loopInThisThread = 0;

 const int kPollTimeMs = 10000;


-
-#pragma GCC diagnostic ignored "-Wold-style-cast"
 class IgnoreSigPipe
 {
  public:
@@ -50,7 +39,6 @@ class IgnoreSigPipe
     // LOG_TRACE << "Ignore SIGPIPE";
   }
 };
-#pragma GCC diagnostic error "-Wold-style-cast"

 IgnoreSigPipe initObj;
 }
@@ -69,11 +57,15 @@ EventLoop::EventLoop()
     threadId_(CurrentThread::tid()),
     poller_(Poller::newDefaultPoller(this)),
     timerQueue_(new TimerQueue(this)),
-    wakeupFd_(createEventfd()),
-    wakeupChannel_(new Channel(this, wakeupFd_)),
     currentActiveChannel_(NULL)
 {
   LOG_DEBUG << "EventLoop created " << this << " in thread " << threadId_;
+  if (::socketpair(AF_UNIX, SOCK_STREAM, 0, wakeupFd_) < 0)
+  {
+    LOG_SYSFATAL << "Failed in socketpair";
+  }
+  wakeupChannel_.reset(new Channel(this, wakeupFd_[0]));
+
   if (t_loopInThisThread)
   {
     LOG_FATAL << "Another EventLoop " << t_loopInThisThread
@@ -95,7 +87,8 @@ EventLoop::~EventLoop()
             << " destructs in thread " << CurrentThread::tid();
   wakeupChannel_->disableAll();
   wakeupChannel_->remove();
-  ::close(wakeupFd_);
+  ::close(wakeupFd_[0]);
+  ::close(wakeupFd_[1]);
   t_loopInThisThread = NULL;
 }

@@ -110,12 +103,13 @@ void EventLoop::loop()
   while (!quit_)
   {
     activeChannels_.clear();
-    pollReturnTime_ = poller_->poll(kPollTimeMs, &activeChannels_);
+    pollReturnTime_ = poller_->poll(timerQueue_->getTimeout(), &activeChannels_);
     ++iteration_;
     if (Logger::logLevel() <= Logger::TRACE)
     {
       printActiveChannels();
     }
+    timerQueue_->processTimers();
     // TODO sort channel by priority
     eventHandling_ = true;
     for (ChannelList::iterator it = activeChannels_.begin();
@@ -273,7 +267,7 @@ void EventLoop::abortNotInLoopThread()
 void EventLoop::wakeup()
 {
   uint64_t one = 1;
-  ssize_t n = sockets::write(wakeupFd_, &one, sizeof one);
+  ssize_t n = sockets::write(wakeupFd_[1], &one, sizeof one);
   if (n != sizeof one)
   {
     LOG_ERROR << "EventLoop::wakeup() writes " << n << " bytes instead of 8";
@@ -283,7 +277,7 @@ void EventLoop::wakeup()
 void EventLoop::handleRead()
 {
   uint64_t one = 1;
-  ssize_t n = sockets::read(wakeupFd_, &one, sizeof one);
+  ssize_t n = sockets::read(wakeupFd_[0], &one, sizeof one);
   if (n != sizeof one)
   {
     LOG_ERROR << "EventLoop::handleRead() reads " << n << " bytes instead of 8";
diff --git a/muduo/net/EventLoop.h b/muduo/net/EventLoop.h
index 5741961..b03dd67 100644
--- a/muduo/net/EventLoop.h
+++ b/muduo/net/EventLoop.h
@@ -156,7 +156,7 @@ class EventLoop : boost::noncopyable
   Timestamp pollReturnTime_;
   boost::scoped_ptr<Poller> poller_;
   boost::scoped_ptr<TimerQueue> timerQueue_;
-  int wakeupFd_;
+  int wakeupFd_[2];
   // unlike in TimerQueue, which is an internal class,
   // we don't expose Channel to client.
   boost::scoped_ptr<Channel> wakeupChannel_;
diff --git a/muduo/net/InetAddress.cc b/muduo/net/InetAddress.cc
index 394870a..05bb5de 100644
--- a/muduo/net/InetAddress.cc
+++ b/muduo/net/InetAddress.cc
@@ -19,10 +19,10 @@
 #include <boost/static_assert.hpp>

 // INADDR_ANY use (type)value casting.
-#pragma GCC diagnostic ignored "-Wold-style-cast"
+// #pragma GCC diagnostic ignored "-Wold-style-cast"
 static const in_addr_t kInaddrAny = INADDR_ANY;
 static const in_addr_t kInaddrLoopback = INADDR_LOOPBACK;
-#pragma GCC diagnostic error "-Wold-style-cast"
+// #pragma GCC diagnostic error "-Wold-style-cast"

 //     /* Structure describing an Internet socket address.  */
 //     struct sockaddr_in {
@@ -83,10 +83,15 @@ bool InetAddress::resolve(StringArg hostname, InetAddress* out)
   assert(out != NULL);
   struct hostent hent;
   struct hostent* he = NULL;
-  int herrno = 0;
   bzero(&hent, sizeof(hent));

+#ifndef __MACH__
+  int herrno = 0;
   int ret = gethostbyname_r(hostname.c_str(), &hent, t_resolveBuffer, sizeof t_resolveBuffer, &he, &herrno);
+#else
+  he = gethostbyname(hostname.c_str());
+  int ret = 0;
+#endif
   if (ret == 0 && he != NULL)
   {
     assert(he->h_addrtype == AF_INET && he->h_length == sizeof(uint32_t));
diff --git a/muduo/net/Socket.cc b/muduo/net/Socket.cc
index 111d87d..4e0efa7 100644
--- a/muduo/net/Socket.cc
+++ b/muduo/net/Socket.cc
@@ -27,13 +27,18 @@ Socket::~Socket()

 bool Socket::getTcpInfo(struct tcp_info* tcpi) const
 {
+#ifndef __MACH__
   socklen_t len = sizeof(*tcpi);
   bzero(tcpi, len);
   return ::getsockopt(sockfd_, SOL_TCP, TCP_INFO, tcpi, &len) == 0;
+#else
+  return false;
+#endif
 }

 bool Socket::getTcpInfoString(char* buf, int len) const
 {
+#ifndef __MACH__
   struct tcp_info tcpi;
   bool ok = getTcpInfo(&tcpi);
   if (ok)
@@ -56,6 +61,9 @@ bool Socket::getTcpInfoString(char* buf, int len) const
              tcpi.tcpi_total_retrans);  // Total retransmits for entire connection
   }
   return ok;
+#else
+  return false;
+#endif
 }

 void Socket::bindAddress(const InetAddress& addr)
diff --git a/muduo/net/SocketsOps.cc b/muduo/net/SocketsOps.cc
index 188c3cb..1e5f268 100644
--- a/muduo/net/SocketsOps.cc
+++ b/muduo/net/SocketsOps.cc
@@ -17,18 +17,26 @@
 #include <stdio.h>  // snprintf
 #include <strings.h>  // bzero
 #include <sys/socket.h>
+#ifdef __MACH__
+#include <sys/uio.h>  // readv
+#endif
 #include <unistd.h>

 using namespace muduo;
 using namespace muduo::net;

-namespace
+namespace muduo
 {

 typedef struct sockaddr SA;


 #if VALGRIND || defined (NO_ACCEPT4)
+namespace net
+{
+namespace sockets
+{
+
 void setNonBlockAndCloseOnExec(int sockfd)
 {
   // non-block
@@ -45,6 +53,9 @@ void setNonBlockAndCloseOnExec(int sockfd)

   (void)ret;
 }
+
+}
+}
 #endif

 }
@@ -71,7 +82,6 @@ struct sockaddr_in* sockets::sockaddr_in_cast(struct sockaddr* addr)

 int sockets::createNonblockingOrDie()
 {
-#if VALGRIND
   int sockfd = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
   if (sockfd < 0)
   {
@@ -79,13 +89,6 @@ int sockets::createNonblockingOrDie()
   }

   setNonBlockAndCloseOnExec(sockfd);
-#else
-  int sockfd = ::socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP);
-  if (sockfd < 0)
-  {
-    LOG_SYSFATAL << "sockets::createNonblockingOrDie";
-  }
-#endif
   return sockfd;
 }

@@ -110,13 +113,8 @@ void sockets::listenOrDie(int sockfd)
 int sockets::accept(int sockfd, struct sockaddr_in* addr)
 {
   socklen_t addrlen = static_cast<socklen_t>(sizeof *addr);
-#if VALGRIND || defined (NO_ACCEPT4)
   int connfd = ::accept(sockfd, sockaddr_cast(addr), &addrlen);
   setNonBlockAndCloseOnExec(connfd);
-#else
-  int connfd = ::accept4(sockfd, sockaddr_cast(addr),
-                         &addrlen, SOCK_NONBLOCK | SOCK_CLOEXEC);
-#endif
   if (connfd < 0)
   {
     int savedErrno = errno;
diff --git a/muduo/net/SocketsOps.h b/muduo/net/SocketsOps.h
index a07b1fe..efc779a 100644
--- a/muduo/net/SocketsOps.h
+++ b/muduo/net/SocketsOps.h
@@ -24,6 +24,9 @@ namespace sockets
 /// Creates a non-blocking socket file descriptor,
 /// abort if any error.
 int createNonblockingOrDie();
+#ifdef __MACH__
+void setNonBlockAndCloseOnExec(int sockfd);
+#endif

 int  connect(int sockfd, const struct sockaddr_in& addr);
 void bindOrDie(int sockfd, const struct sockaddr_in& addr);
diff --git a/muduo/net/TimerQueue.cc b/muduo/net/TimerQueue.cc
index 0f199e5..7f4813a 100644
--- a/muduo/net/TimerQueue.cc
+++ b/muduo/net/TimerQueue.cc
@@ -19,8 +19,6 @@

 #include <boost/bind.hpp>

-#include <sys/timerfd.h>
-
 namespace muduo
 {
 namespace net
@@ -28,57 +26,15 @@ namespace net
 namespace detail
 {

-int createTimerfd()
-{
-  int timerfd = ::timerfd_create(CLOCK_MONOTONIC,
-                                 TFD_NONBLOCK | TFD_CLOEXEC);
-  if (timerfd < 0)
-  {
-    LOG_SYSFATAL << "Failed in timerfd_create";
-  }
-  return timerfd;
-}
-
-struct timespec howMuchTimeFromNow(Timestamp when)
+int howMuchTimeFromNow(Timestamp when)
 {
   int64_t microseconds = when.microSecondsSinceEpoch()
                          - Timestamp::now().microSecondsSinceEpoch();
-  if (microseconds < 100)
-  {
-    microseconds = 100;
-  }
-  struct timespec ts;
-  ts.tv_sec = static_cast<time_t>(
-      microseconds / Timestamp::kMicroSecondsPerSecond);
-  ts.tv_nsec = static_cast<long>(
-      (microseconds % Timestamp::kMicroSecondsPerSecond) * 1000);
-  return ts;
-}
-
-void readTimerfd(int timerfd, Timestamp now)
-{
-  uint64_t howmany;
-  ssize_t n = ::read(timerfd, &howmany, sizeof howmany);
-  LOG_TRACE << "TimerQueue::handleRead() " << howmany << " at " << now.toString();
-  if (n != sizeof howmany)
-  {
-    LOG_ERROR << "TimerQueue::handleRead() reads " << n << " bytes instead of 8";
-  }
-}
-
-void resetTimerfd(int timerfd, Timestamp expiration)
-{
-  // wake up loop by timerfd_settime()
-  struct itimerspec newValue;
-  struct itimerspec oldValue;
-  bzero(&newValue, sizeof newValue);
-  bzero(&oldValue, sizeof oldValue);
-  newValue.it_value = howMuchTimeFromNow(expiration);
-  int ret = ::timerfd_settime(timerfd, 0, &newValue, &oldValue);
-  if (ret)
+  if (microseconds < 1000)
   {
-    LOG_SYSERR << "timerfd_settime()";
+    microseconds = 1000;
   }
+  return static_cast<int>(microseconds / 1000);
 }

 }
@@ -91,22 +47,13 @@ using namespace muduo::net::detail;

 TimerQueue::TimerQueue(EventLoop* loop)
   : loop_(loop),
-    timerfd_(createTimerfd()),
-    timerfdChannel_(loop, timerfd_),
     timers_(),
     callingExpiredTimers_(false)
 {
-  timerfdChannel_.setReadCallback(
-      boost::bind(&TimerQueue::handleRead, this));
-  // we are always reading the timerfd, we disarm it with timerfd_settime.
-  timerfdChannel_.enableReading();
 }

 TimerQueue::~TimerQueue()
 {
-  timerfdChannel_.disableAll();
-  timerfdChannel_.remove();
-  ::close(timerfd_);
   // do not remove channel, since we're in EventLoop::dtor();
   for (TimerList::iterator it = timers_.begin();
       it != timers_.end(); ++it)
@@ -146,11 +93,19 @@ void TimerQueue::cancel(TimerId timerId)
 void TimerQueue::addTimerInLoop(Timer* timer)
 {
   loop_->assertInLoopThread();
-  bool earliestChanged = insert(timer);
+  insert(timer);
+}

-  if (earliestChanged)
+int TimerQueue::getTimeout() const
+{
+  loop_->assertInLoopThread();
+  if (timers_.empty())
+  {
+    return 10000;
+  }
+  else
   {
-    resetTimerfd(timerfd_, timer->expiration());
+    return howMuchTimeFromNow(timers_.begin()->second->expiration());
   }
 }

@@ -174,11 +129,10 @@ void TimerQueue::cancelInLoop(TimerId timerId)
   assert(timers_.size() == activeTimers_.size());
 }

-void TimerQueue::handleRead()
+void TimerQueue::processTimers()
 {
   loop_->assertInLoopThread();
   Timestamp now(Timestamp::now());
-  readTimerfd(timerfd_, now);

   std::vector<Entry> expired = getExpired(now);

@@ -242,11 +196,6 @@ void TimerQueue::reset(const std::vector<Entry>& expired, Timestamp now)
   {
     nextExpire = timers_.begin()->second->expiration();
   }
-
-  if (nextExpire.valid())
-  {
-    resetTimerfd(timerfd_, nextExpire);
-  }
 }

 bool TimerQueue::insert(Timer* timer)
diff --git a/muduo/net/TimerQueue.h b/muduo/net/TimerQueue.h
index 0cfb02f..d882b71 100644
--- a/muduo/net/TimerQueue.h
+++ b/muduo/net/TimerQueue.h
@@ -56,6 +56,9 @@ class TimerQueue : boost::noncopyable

   void cancel(TimerId timerId);

+  int getTimeout() const;
+  void processTimers();
+
  private:

   // FIXME: use unique_ptr<Timer> instead of raw pointers.
@@ -66,8 +69,6 @@ class TimerQueue : boost::noncopyable

   void addTimerInLoop(Timer* timer);
   void cancelInLoop(TimerId timerId);
-  // called when timerfd alarms
-  void handleRead();
   // move out all expired timers
   std::vector<Entry> getExpired(Timestamp now);
   void reset(const std::vector<Entry>& expired, Timestamp now);
@@ -75,9 +76,6 @@ class TimerQueue : boost::noncopyable
   bool insert(Timer* timer);

   EventLoop* loop_;
-  const int timerfd_;
-  Channel timerfdChannel_;
-  // Timer list sorted by expiration
   TimerList timers_;

   // for cancel()
diff --git a/muduo/net/poller/DefaultPoller.cc b/muduo/net/poller/DefaultPoller.cc
index f42f5a4..a6a3133 100644
--- a/muduo/net/poller/DefaultPoller.cc
+++ b/muduo/net/poller/DefaultPoller.cc
@@ -16,6 +16,9 @@ using namespace muduo::net;

 Poller* Poller::newDefaultPoller(EventLoop* loop)
 {
+#ifdef __MACH__
+  return new PollPoller(loop);
+#else
   if (::getenv("MUDUO_USE_POLL"))
   {
     return new PollPoller(loop);
@@ -24,4 +27,5 @@ Poller* Poller::newDefaultPoller(EventLoop* loop)
   {
     return new EPollPoller(loop);
   }
+#endif
 }

diff --git a/examples/protobuf/rpcbalancer/balancer_raw.cc b/examples/protobuf/rpcbalancer/balancer_raw.cc
index 9c2e1db..c30b19d 100644
--- a/examples/protobuf/rpcbalancer/balancer_raw.cc
+++ b/examples/protobuf/rpcbalancer/balancer_raw.cc
@@ -12,7 +12,7 @@
 #include <boost/bind.hpp>
 #include <boost/ptr_container/ptr_vector.hpp>

-#include <endian.h>
+#include <machine/endian.h>
 #include <stdio.h>

 using namespace muduo;
